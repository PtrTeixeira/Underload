#lang racket

;; I want a macro that transforms (equal?| x (or "a" "b" "c")) => (or (equal x "a") (equal x "b") (equal x "c"))


(provide (all-defined-out))

;; A Token is one of
;; - "(.*)"
;; - ":"
;; - "~"
;; - "*"
;; - "a"
;; - "^"
;; - "!"
;; - "S"


;; A Classification is one of
;; - 'push
;; - 'concat
;; - 'duplicate
;; - 'swap
;; - 'enclose
;; - 'eval
;; - 'drop
;; - 'print

;; A State is a (make-state [List Token] [List String])
(define-struct state (program stack))

;; tokenize: String -> [List Token]
;; Breaks the input string into tokens, as per underload.
;; Throws an error upon hitting an unrecognized token
(define (tokenize str)
  ;; take-token: String -> Token
  ;; Produce the first token present in the string
  (define (take-token str)
    (let ((fst (substring str 0 1)))
      (cond [(or (string=? fst ":") (string=? fst "~")
                 (string=? fst "*") (string=? fst "a")
                 (string=? fst "^") (string=? fst "!")
                 (string=? fst "S")) fst]
            [(string=? fst "(") (take-push-token str)]
            [else (error (string-append "Unrecognized character: " fst))])))
  
  ;; take-push-token-helper: String String Int -> Token
  ;; Helper method to count off paren depth
  (define (take-push-token-helper str build depth)
  (cond [(zero? depth) build]
        [else 
         (let ((fst (substring str 0 1))
               (rst (substring str 1)))
                (cond [(string=? fst "(") 
                       (take-push-token-helper 
                        rst (string-append build fst) (+ depth 1))]
                      [(string=? fst ")")
                       (take-push-token-helper 
                        rst (string-append build fst) (- depth 1))]
                      [else 
                       (take-push-token-helper 
                        rst (string-append build fst) depth)]))]))

  ;; take-push-token: String -> Token
  ;; Parse and return a push token
  (define (take-push-token str)
    (take-push-token-helper (substring str 1) "(" 1))

  ;; drop-token: String -> String
  ;; Return the string, absent the first token present
  (define (drop-token str token)
    (substring str (string-length token)))

  (cond [(string=? str "") '()]
        [else (let ((token (take-token str)))
                (cons token (tokenize (drop-token str token))))]))

;; classify: Token -> Classification
;; Classify each token by the action that is required
(define (classify token)
  (cond [(string=? token ":") 'duplicate]
        [(string=? token "~") 'swap]
        [(string=? token "*") 'concat]
        [(string=? token "a") 'enclose]
        [(string=? token "^") 'eval]
        [(string=? token "!") 'drop]
        [(string=? token "S") 'print]
        [else 'push]))

;; print-state: State -> String
;; Do a print-out of the current state
(define (print-state state)
  ;; [List <String|Token>] -> String
  (define (prgm-string lst)
    (if (empty? lst) ""
        (string-append (first lst) (prgm-string (rest lst)))))
  (string-append (prgm-string (state-program state)) 
                 "\n" (prgm-string (state-stack state))))


;; Push: State -> State
;; Guarded: prgm non-empty
;; Push token from program to stack
(define (push state) 
  (let ((fst (first (state-program state))))
    (make-state (rest (state-program state))
                (cons fst (state-stack state)))))
;; Duplicate: State -> State
;; Guarded: prgm non-empty
;; Throw error if trying to duplicate on empty stack
;; Duplicate top element of stack
(define (duplicate state)
  (if (empty? (state-stack state)) 
      (error 
       (string-append "Attempted to duplicate on empty stack: " 
                      (print-state state)))
      (make-state 
       (rest (state-program state))
       (cons (first (state-stack state)) (state-stack state)))))

(define )


;; run: State -> [List String]
(define (run state)
  (define prgm (state-program state))
  (define stck (state-stack state))

  
  (if (empty? prgm) stck 
      (letrec ((fst (first prgm))
               (type (classify fst)))
        (cond [(symbol=? type 'push) (run (push state))]
              [(symbol=? type 'duplicate) (run (duplicate state))]
              [(symbol=? type 'swap) ""]
              [(symbol=? type 'concat) ""]
              [(symbol=? type 'enclose) ""]
              [(symbol=? type 'drop) ""]
              [(symbol=? type 'print) ""]
              [(symbol=? type 'eval) ""]))))